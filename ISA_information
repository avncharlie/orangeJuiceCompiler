
instructions:

global <dst>
    move global object into register
    dst must be register

mov <dst> <src>
    mov src to dst
    dst must be register
    src can be either register or number literal

add <a> <b> <dst>
    calc a+b, store in dst 
    dst must be register
    a and b can be either registers or number literals

sub <a> <b> <dst>
    calc a-b, store in dst 
    dst must be register
    a and b can be either registers or number literals

mul <a> <b> <dst>
    calc a*b, store in dst 
    dst must be register
    a and b can be either registers or number literals

div <a> <b> <dst>
    calc a/b, store in dst 
    dst must be register
    a and b can be either registers or number literals

jmp <label>
    jump execution to label

jt <cond> <label>
    if cond, jump to label (jump true)
    cond must be a register

jnt <cond> <label>
    if not cond, jump to label (jump not true)
    cond must be a register

setvar <var> <value>
    set variable 'var' to value
    var must be string
    value can be either register or literal

getvar <var> <dst>
    retrieve variables 'var' to register
    var must be string
    dst must be register

delvar <var>
    delete variable 'var'
    var must be string

arr <dst>
    load empty array into register
    dst must be register

arrpush <arr> <elem>
    push item into array 
    arr must be register
    elem can be either register or literal

obj <dst>
    load empty object into register
    dst must be register

setprop <obj> <prop> <value>
    set property on object
    obj must be register
    prop can be either register or literal
    value can be either register or literal

getprop <obj> <prop> <dst>
    retrieve property from object into dst
    obj must be register
    prop can be either register or literal
    dst must be register

eq <r1> <r2> <ans>
    check if r1 == r2, store in ans
    r1, r2 and ans must be registers

neq <r1> <r2> <ans>
    check if r1 != r2, store in ans
    r1, r2 and ans must be registers

eqt <r1> <r2> <ans>
    check if r1 === r2, store in ans
    r1, r2 and ans must be registers

neqt <r1> <r2> <ans>
    check if r1 !== r2, store in ans
    r1, r2 and ans must be registers

ge <r1> <r2> <ans>
    calc r1 > r2, store in ans
    r1, r2 and ans must be registers

geeq <r1> <r2> <ans>
    calc r1 > r2, store in ans
    r1, r2 and ans must be registers

le <r1> <r2> <ans>
    calc r1 < r2, store in ans
    r1, r2 and ans must be registers

leeq <r1> <r2> <ans>
    calc r1 <= r2, store in ans
    r1, r2 and ans must be registers

mod <r1> <r2> <ans>
    calc r1 % r2, store in ans
    r1, r2 and ans must be registers

shl <r1> <r2> <ans>
    calc r1 << r2, store in ans
    r1, r2 and ans must be registers

shr <r1> <r2> <ans>
    calc r1 >> r2, store in ans
    r1, r2 and ans must be registers

ushr <r1> <r2> <ans>
    calc r1 >>> r2, store in ans
    r1, r2 and ans must be registers

bit_and <r1> <r2> <ans>
    calc r1 & r2, store in ans
    r1, r2 and ans must be registers

bit_or <r1> <r2> <ans>
    calc r1 | r2, store in ans
    r1, r2 and ans must be registers

xor <r1> <r2> <ans>
    calc r1 ^ r2, store in ans
    r1, r2 and ans must be registers

pow <r1> <r2> <ans>
    calc r1 ** r2, store in ans

inside <r1> <r2> <ans>
    calc r1 in r2, store in ans
    r1, r2 and ans must be registers

check_instance <r1> <r2> <ans>
    calc r1 in r2, store in ans
    r1, r2 and ans must be registers

unary_plus <r1> <ans>
    calc +r1, store in ans
    r2 and ans must be registers

unary_neg <r1> <ans>
    calc -r1, store in ans
    r2 and ans must be registers

unary_not <r1> <ans>
    calc !r1, store in ans
    r2 and ans must be registers

unary_bit_not <r1> <ans>
    calc !r1, store in ans
    r2 and ans must be registers

unary_typeof <r1> <ans>
    calc typeof r1, store in ans
    r2 and ans must be registers

nop
    no operation - do nothing

whatsthis <r>
    load current this into r
    r must be a register

createfunc 'label' <arglist> <r>
    create a wrapper function and store in r
    need label to start running vm at on function call and list of parameter
    names
    label must be a label
    arglist must a register (containing a list)
    r must be a register

return <r>
    return something back
    r can either be a register or a literal 

call <function> <args> <context> <result>
    calls function with context and arguments and stores it in result register
    specifically:
        function.apply(context, args)

    function must be a register with a function
    args must be a register with a list of arguments
    context must be a register
    result must be a register

push_store
    pushes new variable store

pop_store
    pops current variable store

regex <pattern> <flags> <reg>
    create regex object and store in reg
    pattern and flags can be either registers or literals
    reg must be a register
